{"version":3,"file":"ssao2.fragment.js","sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/ssao2.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkKd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,gBAAgB;AAChB,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssao2PixelShader\";\nconst shader = `precision highp float;\runiform sampler2D textureSampler;\rvarying vec2 vUV;\r#ifdef SSAO\nfloat scales[16]=float[16](\r0.1,\r0.11406250000000001,\r0.131640625,\r0.15625,\r0.187890625,\r0.2265625,\r0.272265625,\r0.325,\r0.384765625,\r0.4515625,\r0.525390625,\r0.60625,\r0.694140625,\r0.7890625,\r0.891015625,\r1.0\r);\runiform float near;\runiform float radius;\runiform sampler2D depthSampler;\runiform sampler2D randomSampler;\runiform sampler2D normalSampler;\runiform float randTextureTiles;\runiform float samplesFactor;\runiform vec3 sampleSphere[SAMPLES];\runiform float totalStrength;\runiform float base;\runiform float xViewport;\runiform float yViewport;\runiform mat3 depthProjection;\runiform float maxZ;\runiform float minZAspect;\runiform vec2 texelSize;\runiform mat4 projection;\rvoid main()\r{\rvec3 random=textureLod(randomSampler,vUV*randTextureTiles,0.0).rgb;\rfloat depth=textureLod(depthSampler,vUV,0.0).r;\rfloat depthSign=depth/abs(depth);\rdepth=depth*depthSign;\rvec3 normal=textureLod(normalSampler,vUV,0.0).rgb;\rfloat occlusion=0.0;\rfloat correctedRadius=min(radius,minZAspect*depth/near);\rvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\rvec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);\rvec3 origin=vViewRay*vDepthFactor;\rvec3 rvec=random*2.0-1.0;\rrvec.z=0.0;\rfloat dotProduct=dot(rvec,normal);\rrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\rvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\rvec3 bitangent=cross(normal,tangent);\rmat3 tbn=mat3(tangent,bitangent,normal);\rfloat difference;\rfor (int i=0; i<SAMPLES; ++i) {\rvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\rsamplePosition=samplePosition*correctedRadius+origin;\rvec4 offset=vec4(samplePosition,1.0);\roffset=projection*offset;\roffset.xyz/=offset.w;\roffset.xy=offset.xy*0.5+0.5;\rif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\rcontinue;\r}\rfloat sampleDepth=abs(textureLod(depthSampler,offset.xy,0.0).r);\rdifference=depthSign*samplePosition.z-sampleDepth;\rfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\rocclusion+=step(EPSILON,difference)*rangeCheck;\r}\rocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\rfloat ao=1.0-totalStrength*occlusion*samplesFactor;\rfloat result=clamp(ao+base,0.0,1.0);\rgl_FragColor=vec4(vec3(result),1.0);\r}\r#endif\n#ifdef BLUR\nuniform float outSize;\runiform float soften;\runiform float tolerance;\runiform int samples;\r#ifndef BLUR_BYPASS\nuniform sampler2D depthSampler;\r#ifdef BLUR_LEGACY\n#define inline\nfloat blur13Bilateral(sampler2D image,vec2 uv,vec2 step) {\rfloat result=0.0;\rvec2 off1=vec2(1.411764705882353)*step;\rvec2 off2=vec2(3.2941176470588234)*step;\rvec2 off3=vec2(5.176470588235294)*step;\rfloat compareDepth=abs(textureLod(depthSampler,uv,0.0).r);\rfloat sampleDepth;\rfloat weight;\rfloat weightSum=30.0;\rresult+=textureLod(image,uv,0.0).r*30.0;\rsampleDepth=abs(textureLod(depthSampler,uv+off1,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+= weight;\rresult+=textureLod(image,uv+off1,0.0).r*weight;\rsampleDepth=abs(textureLod(depthSampler,uv-off1,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+= weight;\rresult+=textureLod(image,uv-off1,0.0).r*weight;\rsampleDepth=abs(textureLod(depthSampler,uv+off2,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rresult+=textureLod(image,uv+off2,0.0).r*weight;\rsampleDepth=abs(textureLod(depthSampler,uv-off2,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rresult+=textureLod(image,uv-off2,0.0).r*weight;\rsampleDepth=abs(textureLod(depthSampler,uv+off3,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rresult+=textureLod(image,uv+off3,0.0).r*weight;\rsampleDepth=abs(textureLod(depthSampler,uv-off3,0.0).r);\rweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\rweightSum+=weight;\rresult+=textureLod(image,uv-off3,0.0).r*weight;\rreturn result/weightSum;\r}\r#endif\n#endif\nvoid main()\r{\rfloat result=0.0;\r#ifdef BLUR_BYPASS\nresult=textureLod(textureSampler,vUV,0.0).r;\r#else\n#ifdef BLUR_H\nvec2 step=vec2(1.0/outSize,0.0);\r#else\nvec2 step=vec2(0.0,1.0/outSize);\r#endif\n#ifdef BLUR_LEGACY\nresult=blur13Bilateral(textureSampler,vUV,step);\r#else\nfloat compareDepth=abs(textureLod(depthSampler,vUV,0.0).r);\rfloat weightSum=0.0;\rfor (int i=-samples; i<samples; i+=2)\r{\rvec2 samplePos=vUV+step*(float(i)+0.5);\rfloat sampleDepth=abs(textureLod(depthSampler,samplePos,0.0).r);\rfloat falloff=smoothstep(0.0,\rfloat(samples),\rfloat(samples)-abs(float(i))*soften);\rfloat minDivider=tolerance*0.5+0.003;\rfloat weight=falloff/( minDivider+abs(compareDepth-sampleDepth));\rresult+=textureLod(textureSampler,samplePos,0.0).r*weight;\rweightSum+=weight;\r}\rresult/=weightSum;\r#endif\n#endif\ngl_FragColor.rgb=vec3(result);\rgl_FragColor.a=1.0;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const ssao2PixelShader = { name, shader };\n"]}