{"version":3,"file":"screenSpaceReflection2.fragment.js","sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/screenSpaceReflection2.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,sCAAsC,CAAC;AAE9C,MAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyNd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,gBAAgB;AAChB,MAAM,CAAC,MAAM,iCAAiC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/screenSpaceRayTrace\";\n\nconst name = \"screenSpaceReflection2PixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)\n#define TEXTURECUBEFUNC(s,c,lod) textureLod(s,c,lod)\n#else\n#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)\n#define TEXTURECUBEFUNC(s,c,bias) textureCube(s,c,bias)\n#endif\nuniform sampler2D textureSampler;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D depthSampler;\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nuniform sampler2D backDepthSampler;\runiform float backSizeFactor;\r#endif\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nuniform samplerCube envCubeSampler;\r#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nuniform vec3 vReflectionPosition;\runiform vec3 vReflectionSize;\r#endif\n#endif\nuniform mat4 view;\runiform mat4 invView;\runiform mat4 projection;\runiform mat4 invProjectionMatrix;\runiform mat4 projectionPixel;\runiform float nearPlaneZ;\runiform float stepSize;\runiform float maxSteps;\runiform float strength;\runiform float thickness;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\runiform float maxDistance;\runiform float selfCollisionNumSkip;\runiform float reflectivityThreshold;\r#include<helperFunctions>\n#include<screenSpaceRayTrace>\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\rvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {\rvec4 ndc;\rndc.xy=texCoord*2.0-1.0;\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nndc.z=-projection[2].z-projection[3].z/depth;\r#else\nndc.z=projection[2].z+projection[3].z/depth;\r#endif\nndc.w=1.0;\rvec4 eyePos=invProjectionMatrix*ndc;\reyePos.xyz/=eyePos.w;\rreturn eyePos.xyz;\r}\rfloat computeAttenuationForIntersection(ivec2 hitPixel,vec2 hitUV,vec3 vsRayOrigin,vec3 vsHitPoint,vec3 reflectionVector,float maxRayDistance,float numIterations) {\rfloat attenuation=1.0;\r#ifdef SSR_ATTENUATE_SCREEN_BORDERS\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-hitUV.xy));\rattenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\r#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE\nattenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);\r#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_NUMITERATIONS\nattenuation*=1.0-(numIterations/maxSteps);\r#endif\n#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION\nvec3 reflectionNormal=texelFetch(normalSampler,hitPixel,0).xyz;\rfloat directionBasedAttenuation=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));\rattenuation*=directionBasedAttenuation;\r#endif\nreturn attenuation;\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 colorFull=TEXTUREFUNC(textureSampler,vUV,0.0);\rvec3 color=colorFull.rgb;\rvec4 reflectivity=TEXTUREFUNC(reflectivitySampler,vUV,0.0);\rif (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=reflectivityThreshold) {\r#ifdef SSR_USE_BLUR\ngl_FragColor=vec4(0.);\r#else\ngl_FragColor=colorFull;\r#endif\nreturn;\r}\r#ifdef SSR_INPUT_IS_GAMMA_SPACE\ncolor=toLinearSpace(color);\r#endif\nvec2 texSize=vec2(textureSize(depthSampler,0));\rvec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz; \rfloat depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;\rvec3 csPosition=computeViewPosFromUVDepth(vUV,depth);\rvec3 csViewDirection=normalize(csPosition);\rvec3 csReflectedVector=reflect(csViewDirection,csNormal);\r#ifdef SSR_USE_ENVIRONMENT_CUBE\nvec3 wReflectedVector=vec3(invView*vec4(csReflectedVector,0.0));\r#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nvec4 worldPos=invView*vec4(csPosition,1.0);\rwReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),vReflectionSize,vReflectionPosition);\r#endif\n#ifdef SSR_INVERTCUBICMAP\nwReflectedVector.y*=-1.0;\r#endif\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nwReflectedVector.z*=-1.0;\r#endif\nvec3 envColor=TEXTURECUBEFUNC(envCubeSampler,wReflectedVector,0.0).xyz;\r#ifdef SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE\nenvColor=toLinearSpace(envColor);\r#endif\n#else\nvec3 envColor=color;\r#endif\nfloat reflectionAttenuation=1.0;\rbool rayHasHit=false;\rvec2 startPixel;\rvec2 hitPixel;\rvec3 hitPoint;\rfloat numIterations;\r#ifdef SSRAYTRACE_DEBUG\nvec3 debugColor;\r#endif\n#ifdef SSR_ATTENUATE_FACING_CAMERA\nreflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));\r#endif\nif (reflectionAttenuation>0.0) {\r#ifdef SSR_USE_BLUR\nvec3 jitt=vec3(0.);\r#else\nfloat roughness=1.0-reflectivity.a;\rvec3 jitt=mix(vec3(0.0),hash(csPosition),roughness)*roughnessFactor; \r#endif\nvec2 uv2=vUV*texSize;\rfloat c=(uv2.x+uv2.y)*0.25;\rfloat jitter=mod(c,1.0); \rrayHasHit=traceScreenSpaceRay1(\rcsPosition,\rnormalize(csReflectedVector+jitt),\rprojectionPixel,\rdepthSampler,\rtexSize,\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nbackDepthSampler,\rbackSizeFactor,\r#endif\nthickness,\rnearPlaneZ,\rstepSize,\rjitter,\rmaxSteps,\rmaxDistance,\rselfCollisionNumSkip,\rstartPixel,\rhitPixel,\rhitPoint,\rnumIterations\r#ifdef SSRAYTRACE_DEBUG\n,debugColor\r#endif\n);\r}\r#ifdef SSRAYTRACE_DEBUG\ngl_FragColor=vec4(debugColor,1.);\rreturn;\r#endif\nvec3 F0=reflectivity.rgb;\rvec3 fresnel=fresnelSchlick(max(dot(csNormal,-csViewDirection),0.0),F0);\rvec3 SSR=envColor;\rif (rayHasHit) {\rvec3 reflectedColor=texelFetch(textureSampler,ivec2(hitPixel),0).rgb;\r#ifdef SSR_INPUT_IS_GAMMA_SPACE\nreflectedColor=toLinearSpace(reflectedColor);\r#endif\nreflectionAttenuation*=computeAttenuationForIntersection(ivec2(hitPixel),hitPixel/texSize,csPosition,hitPoint,csReflectedVector,maxDistance,numIterations);\rSSR=reflectedColor*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;\r}\rSSR*=fresnel;\r#ifdef SSR_USE_BLUR\nfloat blur_radius=0.0;\rfloat roughness=1.0-reflectivity.a*(1.0-roughnessFactor);\rif (roughness>0.001) {\rfloat cone_angle=min(roughness,0.999)*3.14159265*0.5;\rfloat cone_len=distance(startPixel,hitPixel);\rfloat op_len=2.0*tan(cone_angle)*cone_len; \rfloat a=op_len;\rfloat h=cone_len;\rfloat a2=a*a;\rfloat fh2=4.0f*h*h;\rblur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);\r}\rgl_FragColor=vec4(SSR,blur_radius/255.0); \r#else\nvec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\rvec3 colorMultiplier=1.0-reflectionMultiplier;\rvec3 finalColor=(color*colorMultiplier)+(SSR*reflectionMultiplier);\r#ifdef SSR_OUTPUT_IS_GAMMA_SPACE\nfinalColor=toGammaSpace(finalColor);\r#endif\ngl_FragColor=vec4(finalColor,colorFull.a);\r#endif\n#else\ngl_FragColor=TEXTUREFUNC(textureSampler,vUV,0.0);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflection2PixelShader = { name, shader };\n"]}