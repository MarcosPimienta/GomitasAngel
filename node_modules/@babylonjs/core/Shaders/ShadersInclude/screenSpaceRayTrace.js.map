{"version":3,"file":"screenSpaceRayTrace.js","sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/ShadersInclude/screenSpaceRayTrace.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AAExD,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyLd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,gBAAgB;AAChB,MAAM,CAAC,MAAM,mBAAmB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"screenSpaceRayTrace\";\nconst shader = `float distanceSquared(vec2 a,vec2 b) { a-=b; return dot(a,a); }\r/**\r\\param csOrigin Camera-space ray origin,which must be \rwithin the view volume and must have z>0.01 and project within the valid screen rectangle\r\\param csDirection Unit length camera-space ray direction\r\\param projectToPixelMatrix A projection matrix that maps to **pixel** coordinates \r(**not** [-1,+1] normalized device coordinates).\r\\param csZBuffer The camera-space Z buffer\r\\param csZBufferSize Dimensions of csZBuffer\r\\param csZThickness Camera space csZThickness to ascribe to each pixel in the depth buffer\r\\param nearPlaneZ Positive number. Doesn't have to be THE actual near plane,just a reasonable value\rfor clipping rays headed towards the camera\r\\param stride Step in horizontal or vertical pixels between samples. This is a float\rbecause integer math is slow on GPUs,but should be set to an integer>=1\r\\param jitterFraction Number between 0 and 1 for how far to bump the ray in stride units\rto conceal banding artifacts,plus the stride ray offset.\r\\param maxSteps Maximum number of iterations. Higher gives better images but may be slow\r\\param maxRayTraceDistance Maximum camera-space distance to trace before returning a miss\r\\param selfCollisionNumSkip Number of steps to skip at start when raytracing to avoid self collisions.\r1 is a reasonable value,depending on the scene you may need to set this value to 2\r\\param hitPixel Pixel coordinates of the first intersection with the scene\r\\param numIterations number of iterations performed\r\\param csHitPoint Camera space location of the ray hit\r*/\r#define inline\nbool traceScreenSpaceRay1(\rvec3 csOrigin,\rvec3 csDirection,\rmat4 projectToPixelMatrix,\rsampler2D csZBuffer,\rvec2 csZBufferSize,\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nsampler2D csZBackBuffer,\rfloat csZBackSizeFactor,\r#endif\nfloat csZThickness,\rfloat nearPlaneZ,\rfloat stride,\rfloat jitterFraction,\rfloat maxSteps,\rfloat maxRayTraceDistance,\rfloat selfCollisionNumSkip,\rout vec2 startPixel,\rout vec2 hitPixel,\rout vec3 csHitPoint,\rout float numIterations\r#ifdef SSRAYTRACE_DEBUG\n,out vec3 debugColor\r#endif\n)\r{\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)>-nearPlaneZ ? (-nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\r#else\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)<nearPlaneZ ? (nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\r#endif\nvec3 csEndPoint=csOrigin+csDirection*rayLength;\rhitPixel=vec2(-1.0,-1.0);\rvec4 H0=projectToPixelMatrix*vec4(csOrigin,1.0);\rvec4 H1=projectToPixelMatrix*vec4(csEndPoint,1.0);\rfloat k0=1.0/H0.w;\rfloat k1=1.0/H1.w;\rvec3 Q0=csOrigin*k0;\rvec3 Q1=csEndPoint*k1;\rvec2 P0=H0.xy*k0;\rvec2 P1=H1.xy*k1;\r#ifdef SSRAYTRACE_CLIP_TO_FRUSTUM\nfloat xMax=csZBufferSize.x-0.5,xMin=0.5,yMax=csZBufferSize.y-0.5,yMin=0.5;\rfloat alpha=0.0;\rif ((P1.y>yMax) || (P1.y<yMin)) {\ralpha=(P1.y-((P1.y>yMax) ? yMax : yMin))/(P1.y-P0.y);\r}\rif ((P1.x>xMax) || (P1.x<xMin)) {\ralpha=max(alpha,(P1.x-((P1.x>xMax) ? xMax : xMin))/(P1.x-P0.x));\r}\rP1=mix(P1,P0,alpha); k1=mix(k1,k0,alpha); Q1=mix(Q1,Q0,alpha);\r#endif\nP1+=vec2((distanceSquared(P0,P1)<0.0001) ? 0.01 : 0.0);\rvec2 delta=P1-P0;\rbool permute=false;\rif (abs(delta.x)<abs(delta.y)) { \rpermute=true;\rdelta=delta.yx;\rP0=P0.yx;\rP1=P1.yx; \r}\rfloat stepDirection=sign(delta.x);\rfloat invdx=stepDirection/delta.x;\rvec2 dP=vec2(stepDirection,delta.y*invdx);\rvec3 dQ=(Q1-Q0)*invdx;\rfloat dk=(k1-k0)*invdx;\rfloat zMin=min(csEndPoint.z,csOrigin.z);\rfloat zMax=max(csEndPoint.z,csOrigin.z);\rdP*=stride; dQ*=stride; dk*=stride;\rP0+=dP*jitterFraction; Q0+=dQ*jitterFraction; k0+=dk*jitterFraction;\rvec4 pqk=vec4(P0,Q0.z,k0);\rvec4 dPQK=vec4(dP,dQ.z,dk);\rstartPixel=permute ? P0.yx : P0.xy;\rfloat prevZMaxEstimate=csOrigin.z;\rfloat rayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;\rfloat sceneZMax=rayZMax+1e4;\rfloat end=P1.x*stepDirection;\rbool hit=false;\rfloat stepCount;\rfor (stepCount=0.0;\rstepCount<=selfCollisionNumSkip ||\r(pqk.x*stepDirection)<=end &&\rstepCount<maxSteps &&\r!hit &&\rsceneZMax != 0.0; \rpqk+=dPQK,++stepCount)\r{\rhitPixel=permute ? pqk.yx : pqk.xy;\rrayZMin=prevZMaxEstimate;\rrayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);\rrayZMax=clamp(rayZMax,zMin,zMax);\rprevZMaxEstimate=rayZMax;\rif (rayZMin>rayZMax) { \rfloat t=rayZMin; rayZMin=rayZMax; rayZMax=t;\r}\rsceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;\rhit=(rayZMax>=sceneBackZ-csZThickness) && (rayZMin<=sceneZMax);\r#else\nhit=(rayZMax>=sceneZMax-csZThickness) && (rayZMin<=sceneZMax);\r#endif\n#else\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;\rhit=(rayZMin<=sceneBackZ+csZThickness) && (rayZMax>=sceneZMax) && (sceneZMax != 0.0);\r#else\nhit=(rayZMin<=sceneZMax+csZThickness) && (rayZMax>=sceneZMax);\r#endif\n#endif\n}\rpqk-=dPQK;\rstepCount-=1.0;\r#ifdef SSRAYTRACE_ENABLE_REFINEMENT\nif (stride>1.0 && hit) {\rpqk-=dPQK;\rstepCount-=1.0;\rfloat invStride=1.0/stride;\rdPQK*=invStride;\rfloat refinementStepCount=0.0;\rprevZMaxEstimate=pqk.z/pqk.w;\rrayZMax=prevZMaxEstimate;\rsceneZMax=rayZMax+1e7;\rfor (;\rrefinementStepCount<=1.0 ||\r(refinementStepCount<=stride*1.4) &&\r(rayZMax<sceneZMax) && (sceneZMax != 0.0);\rpqk+=dPQK,refinementStepCount+=1.0)\r{\rrayZMin=prevZMaxEstimate;\rrayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);\rrayZMax=clamp(rayZMax,zMin,zMax);\rprevZMaxEstimate=rayZMax;\rrayZMax=max(rayZMax,rayZMin);\rhitPixel=permute ? pqk.yx : pqk.xy;\rsceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;\r}\rpqk-=dPQK;\rrefinementStepCount-=1.0;\rstepCount+=refinementStepCount/stride;\r}\r#endif\nQ0.xy+=dQ.xy*stepCount;\rQ0.z=pqk.z;\rcsHitPoint=Q0/pqk.w;\rnumIterations=stepCount+1.0;\r#ifdef SSRAYTRACE_DEBUG\nif (((pqk.x+dPQK.x)*stepDirection)>end) {\rdebugColor=vec3(0,0,1);\r} else if ((stepCount+1.0)>=maxSteps) {\rdebugColor=vec3(1,0,0);\r} else if (sceneZMax==0.0) {\rdebugColor=vec3(1,1,0);\r} else {\rdebugColor=vec3(0,stepCount/maxSteps,0);\r}\r#endif\nreturn hit;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceRayTrace = { name, shader };\n"]}