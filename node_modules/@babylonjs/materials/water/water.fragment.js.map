{"version":3,"file":"water.fragment.js","sourceRoot":"","sources":["../../../../lts/materials/generated/water/water.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,+CAAiC;AACvD,mEAAqD;AACrD,8EAAgE;AAChE,4EAA8D;AAC9D,4EAA8D;AAC9D,uEAAyD;AACzD,2EAA6D;AAC7D,4EAA8D;AAC9D,gFAAkE;AAClE,uEAAyD;AACzD,0EAA4D;AAC5D,qEAAuD;AACvD,iEAAmD;AACnD,oEAAsD;AACtD,+DAAiD;AAEjD,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmLd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,gBAAgB;AAChB,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/imageProcessingDeclaration\";\nimport \"core/Shaders/ShadersInclude/imageProcessingFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\n\nconst name = \"waterPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef BUMP\nvarying vec2 vNormalUV;\r#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\r#endif\nuniform sampler2D normalSampler;\runiform vec2 vNormalInfos;\r#endif\nuniform sampler2D refractionSampler;\runiform sampler2D reflectionSampler;\rconst float LOG2=1.442695;\runiform vec3 cameraPosition;\runiform vec4 waterColor;\runiform float colorBlendFactor;\runiform vec4 waterColor2;\runiform float colorBlendFactor2;\runiform float bumpHeight;\runiform float time;\rvarying vec3 vRefractionMapTexCoord;\rvarying vec3 vReflectionMapTexCoord;\rvarying vec3 vPosition;\r#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\r#else\nbaseColor=texture2D(normalSampler,vNormalUV);\r#endif\nvec3 bumpColor=baseColor.rgb;\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\nbaseColor.rgb*=vNormalInfos.y;\r#else\nvec3 bumpColor=vec3(1.0);\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\r#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));\rif (normalW.y<0.0) {\rnormalW.y=-normalW.y;\r}\r#else\nvec3 normalW=normalize(vNormalW);\r#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\rvec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\r#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\rvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\rvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\r),0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);\rfloat IfresnelTerm=1.0-fresnelTerm;\rrefractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;\rreflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;\rbaseColor=combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#else \n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=max(dot(viewDirectionW,upVector),0.0);\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);\rbaseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#endif\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\r#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);\rcolor=applyImageProcessing(color);\r#endif\ngl_FragColor=color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterPixelShader = { name, shader };\n"]}