{"version":3,"file":"glTFMaterialExporter.js","sourceRoot":"","sources":["../../../../../lts/serializers/generated/glTF/2.0/glTFMaterialExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IMaterialExtension } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\ndeclare type Material = import(\"core/Materials/material\").Material;\r\ndeclare type StandardMaterial = import(\"core/Materials/standardMaterial\").StandardMaterial;\r\ndeclare type PBRBaseMaterial = import(\"core/Materials/PBR/pbrBaseMaterial\").PBRBaseMaterial;\r\ndeclare type PBRMaterial = import(\"core/Materials/PBR/pbrMaterial\").PBRMaterial;\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n     */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n     */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n     */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metalness of the material\r\n     */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n     */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture data\r\n     */\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    /**\r\n     * The base color texture data\r\n     */\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction getFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @internal\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images.\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static _FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) && Scalar.WithinEpsilon(color1.g, color2.g, epsilon) && Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param exportMaterials\r\n     * @param mimeType texture mime type\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(exportMaterials: Set<Material>, mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        const promises: Promise<IMaterial>[] = [];\r\n        exportMaterials.forEach((material) => {\r\n            if (material.getClassName() === \"StandardMaterial\") {\r\n                promises.push(this._convertStandardMaterialAsync(material as StandardMaterial, mimeType, hasTextureCoords));\r\n            } else if (material.getClassName().indexOf(\"PBR\") !== -1) {\r\n                promises.push(this._convertPBRMaterialAsync(material as PBRMaterial, mimeType, hasTextureCoords));\r\n            } else {\r\n                Tools.Warn(`Unsupported material type: ${material.name}`);\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        const newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (material.extensions) {\r\n            for (const extension in material.extensions) {\r\n                const extensionObject = material.extensions[extension];\r\n                if (extensionObject as IMaterialExtension) {\r\n                    return extensionObject.hasTextures?.();\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        if (babylonTexture) {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        // Defines a cubic bezier curve where x is specular power and y is roughness\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function solveForRoughness(specularPower: number): number {\r\n            // Given P0.x = 0, P1.x = 0, P2.x = 0\r\n            //   x = t * t * t * P3.x\r\n            //   t = (x / P3.x)^(1/3)\r\n            const t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n        const opacity = babylonStandardMaterial.alpha;\r\n        const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = (diffuse * oneMinusSpecularStrength) / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        } else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const pbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(bumpTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter._FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        materials.push(material);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, material, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (const texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                const extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private async _getImageDataAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        const hostingScene = this._exporter._babylonScene;\r\n        const engine = hostingScene.getEngine();\r\n\r\n        // Create a temporary texture with the texture buffer data\r\n        const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n        await TextureTools.ApplyPostProcess(\"pass\", tempTexture, hostingScene, textureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        const data = await engine._readTexturePixels(tempTexture, width, height);\r\n\r\n        return (await DumpTools.DumpDataAsync(width, height, data, mimeType, undefined, true, true)) as ArrayBuffer;\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        } else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        } else {\r\n            throw new Error(\"Unsupported pixel format!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: _IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject(\"_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /=\r\n                        metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(\r\n            oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon)\r\n        );\r\n        const baseColorFromSpecular = specularGlossiness.specularColor\r\n            .subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic))\r\n            .scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const baseColor = babylonPBRMaterial._albedoColor;\r\n        const metallic = babylonPBRMaterial._metallic;\r\n        const roughness = babylonPBRMaterial._roughness;\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: roughness,\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonPBRMaterial._albedoTexture!, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(metallicTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial._albedoColor,\r\n                specularColor: babylonPBRMaterial._reflectivityColor,\r\n                glossiness: babylonPBRMaterial._microSurface,\r\n            };\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n            const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n            if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((albedoTexture || reflectivityTexture) && hasTextureCoords) {\r\n                const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    const textures = this._exporter._textures;\r\n                    if (metallicRoughnessFactors.baseColorTextureData) {\r\n                        const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                        pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                        const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                        pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            } else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Base Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Base Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        } else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _setMetallicRoughnessPbrMaterial(\r\n        metallicRoughness: Nullable<_IPBRMetallicRoughness>,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        mimeType: ImageMimeType,\r\n        hasTextureCoords: boolean\r\n    ): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial as PBRMaterial);\r\n            if (\r\n                !(\r\n                    _GLTFMaterialExporter._FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) &&\r\n                    babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon\r\n                )\r\n            ) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial._twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n                if (bumpTexture) {\r\n                    const promise = this._exportTextureAsync(bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n                if (ambientTexture) {\r\n                    const promise = this._exportTextureAsync(ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n                if (emissiveTexture) {\r\n                    const promise = this._exportTextureAsync(emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n            if (!_GLTFMaterialExporter._FuzzyEquals(emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private _getPixelsFromTexture(babylonTexture: BaseTexture): Promise<Nullable<Uint8Array | Float32Array>> {\r\n        const pixels =\r\n            babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT\r\n                ? (babylonTexture.readPixels() as Promise<Uint8Array>)\r\n                : (babylonTexture.readPixels() as Promise<Float32Array>);\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public async _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const textureUid = babylonTexture.uid;\r\n        if (!(textureUid in this._textureMap)) {\r\n            const pixels = await this._getPixelsFromTexture(babylonTexture);\r\n            if (!pixels) {\r\n                return null;\r\n            }\r\n\r\n            const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n\r\n            // Preserve texture mime type if defined\r\n            const textureMimeType = (babylonTexture as Texture).mimeType;\r\n            if (textureMimeType) {\r\n                switch (textureMimeType) {\r\n                    case \"image/jpeg\":\r\n                    case \"image/png\":\r\n                    case \"image/webp\":\r\n                        mimeType = textureMimeType as ImageMimeType;\r\n                        break;\r\n                    default:\r\n                        Tools.Warn(`Unsupported media type: ${textureMimeType}`);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            const internalTextureToImage = this._internalTextureToImage;\r\n            const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n            internalTextureToImage[internalTextureUniqueId] ||= {};\r\n            let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][mimeType];\r\n            if (imageIndexPromise === undefined) {\r\n                const size = babylonTexture.getSize();\r\n                imageIndexPromise = (async () => {\r\n                    const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n                    return this._exportImage(babylonTexture.name, mimeType, data);\r\n                })();\r\n                internalTextureToImage[internalTextureUniqueId][mimeType] = imageIndexPromise;\r\n            }\r\n\r\n            const textureInfo = this._exportTextureInfo(await imageIndexPromise, samplerIndex, babylonTexture.coordinatesIndex);\r\n            this._textureMap[textureUid] = textureInfo;\r\n            this._exporter._extensionsPostExportTextures(\"exporter\", this._textureMap[textureUid], babylonTexture);\r\n        }\r\n\r\n        return this._textureMap[textureUid];\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const imageData = this._exporter._imageData;\r\n\r\n        const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n        const extension = getFileExtensionFromMimeType(mimeType);\r\n        let fileName = baseName + extension;\r\n        if (fileName in imageData) {\r\n            fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[fileName] = {\r\n            data: data,\r\n            mimeType: mimeType,\r\n        };\r\n\r\n        const images = this._exporter._images;\r\n        images.push({\r\n            name: name,\r\n            uri: fileName,\r\n        });\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n"]}