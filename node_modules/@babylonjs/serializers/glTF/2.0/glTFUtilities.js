import { Vector3 } from "@babylonjs/core/Maths/math.vector.js";
/**
 * @internal
 */
export class _GLTFUtilities {
    /**
     * Creates a buffer view based on the supplied arguments
     * @param bufferIndex index value of the specified buffer
     * @param byteOffset byte offset value
     * @param byteLength byte length of the bufferView
     * @param byteStride byte distance between conequential elements
     * @param name name of the buffer view
     * @returns bufferView for glTF
     */
    static _CreateBufferView(bufferIndex, byteOffset, byteLength, byteStride, name) {
        const bufferview = { buffer: bufferIndex, byteLength: byteLength };
        if (byteOffset) {
            bufferview.byteOffset = byteOffset;
        }
        if (name) {
            bufferview.name = name;
        }
        if (byteStride) {
            bufferview.byteStride = byteStride;
        }
        return bufferview;
    }
    /**
     * Creates an accessor based on the supplied arguments
     * @param bufferviewIndex The index of the bufferview referenced by this accessor
     * @param name The name of the accessor
     * @param type The type of the accessor
     * @param componentType The datatype of components in the attribute
     * @param count The number of attributes referenced by this accessor
     * @param byteOffset The offset relative to the start of the bufferView in bytes
     * @param min Minimum value of each component in this attribute
     * @param max Maximum value of each component in this attribute
     * @returns accessor for glTF
     */
    static _CreateAccessor(bufferviewIndex, name, type, componentType, count, byteOffset, min, max) {
        const accessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };
        if (min != null) {
            accessor.min = min;
        }
        if (max != null) {
            accessor.max = max;
        }
        if (byteOffset != null) {
            accessor.byteOffset = byteOffset;
        }
        return accessor;
    }
    /**
     * Calculates the minimum and maximum values of an array of position floats
     * @param positions Positions array of a mesh
     * @param vertexStart Starting vertex offset to calculate min and max values
     * @param vertexCount Number of vertices to check for min and max values
     * @param convertToRightHandedSystem
     * @returns min number array and max number array
     */
    static _CalculateMinMaxPositions(positions, vertexStart, vertexCount, convertToRightHandedSystem) {
        const min = [Infinity, Infinity, Infinity];
        const max = [-Infinity, -Infinity, -Infinity];
        const positionStrideSize = 3;
        let indexOffset;
        let position;
        let vector;
        if (vertexCount) {
            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {
                indexOffset = positionStrideSize * i;
                position = Vector3.FromArray(positions, indexOffset);
                if (convertToRightHandedSystem) {
                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);
                }
                vector = position.asArray();
                for (let j = 0; j < positionStrideSize; ++j) {
                    const num = vector[j];
                    if (num < min[j]) {
                        min[j] = num;
                    }
                    if (num > max[j]) {
                        max[j] = num;
                    }
                    ++indexOffset;
                }
            }
        }
        return { min, max };
    }
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    static _GetRightHandedPositionVector3(vector) {
        return new Vector3(vector.x, vector.y, -vector.z);
    }
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    static _GetRightHandedPositionVector3FromRef(vector) {
        vector.z *= -1;
    }
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    static _GetRightHandedPositionArray3FromRef(vector) {
        vector[2] *= -1;
    }
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    static _GetRightHandedNormalVector3(vector) {
        return new Vector3(vector.x, vector.y, -vector.z);
    }
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    static _GetRightHandedNormalVector3FromRef(vector) {
        vector.z *= -1;
    }
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    static _GetRightHandedNormalArray3FromRef(vector) {
        vector[2] *= -1;
    }
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    static _GetRightHandedVector4FromRef(vector) {
        vector.z *= -1;
        vector.w *= -1;
    }
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    static _GetRightHandedArray4FromRef(vector) {
        vector[2] *= -1;
        vector[3] *= -1;
    }
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    static _GetRightHandedQuaternionFromRef(quaternion) {
        quaternion.x *= -1;
        quaternion.y *= -1;
    }
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    static _GetRightHandedQuaternionArrayFromRef(quaternion) {
        quaternion[0] *= -1;
        quaternion[1] *= -1;
    }
    static _NormalizeTangentFromRef(tangent) {
        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);
        if (length > 0) {
            tangent.x /= length;
            tangent.y /= length;
            tangent.z /= length;
        }
    }
    static _GetDataAccessorElementCount(accessorType) {
        switch (accessorType) {
            case "MAT2" /* AccessorType.MAT2 */:
                return 4;
            case "MAT3" /* AccessorType.MAT3 */:
                return 9;
            case "MAT4" /* AccessorType.MAT4 */:
                return 16;
            case "SCALAR" /* AccessorType.SCALAR */:
                return 1;
            case "VEC2" /* AccessorType.VEC2 */:
                return 2;
            case "VEC3" /* AccessorType.VEC3 */:
                return 3;
            case "VEC4" /* AccessorType.VEC4 */:
                return 4;
        }
    }
}
//# sourceMappingURL=glTFUtilities.js.map