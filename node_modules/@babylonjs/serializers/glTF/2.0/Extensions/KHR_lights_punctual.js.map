{"version":3,"file":"KHR_lights_punctual.js","sourceRoot":"","sources":["../../../../../../lts/serializers/generated/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { _GLTFUtilities } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: _Exporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter!._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of unique id to glTF node index\r\n     * @returns nullable INode promise\r\n     */\r\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: { [key: number]: number }): Promise<Nullable<INode>> {\r\n        return new Promise((resolve) => {\r\n            if (node && babylonNode instanceof ShadowLight) {\r\n                const babylonLight: ShadowLight = babylonNode;\r\n                let light: IKHRLightsPunctual_Light;\r\n\r\n                const lightType =\r\n                    babylonLight.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                        ? KHRLightsPunctual_LightType.POINT\r\n                        : babylonLight.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                        ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                        : babylonLight.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                        ? KHRLightsPunctual_LightType.SPOT\r\n                        : null;\r\n                if (lightType == null) {\r\n                    Logger.Warn(`${context}: Light ${babylonLight.name} is not supported in ${NAME}`);\r\n                } else {\r\n                    const lightPosition = babylonLight.position.clone();\r\n                    const convertToRightHandedSystem = this._exporter._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                    if (!lightPosition.equals(Vector3.Zero())) {\r\n                        if (convertToRightHandedSystem) {\r\n                            _GLTFUtilities._GetRightHandedPositionVector3FromRef(lightPosition);\r\n                        }\r\n                        node.translation = lightPosition.asArray();\r\n                    }\r\n                    if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                        const localAxis = babylonLight.direction;\r\n                        const yaw = -Math.atan2(localAxis.z * (this._exporter._babylonScene.useRightHandedSystem ? -1 : 1), localAxis.x) + Math.PI / 2;\r\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n                        const pitch = -Math.atan2(localAxis.y, len);\r\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw, pitch, 0);\r\n                        if (convertToRightHandedSystem) {\r\n                            _GLTFUtilities._GetRightHandedQuaternionFromRef(lightRotationQuaternion);\r\n                        }\r\n                        if (!lightRotationQuaternion.equals(Quaternion.Identity())) {\r\n                            node.rotation = lightRotationQuaternion.asArray();\r\n                        }\r\n                    }\r\n\r\n                    if (babylonLight.falloffType !== Light.FALLOFF_GLTF) {\r\n                        Logger.Warn(`${context}: Light falloff for ${babylonLight.name} does not match the ${NAME} specification!`);\r\n                    }\r\n                    light = {\r\n                        type: lightType,\r\n                    };\r\n                    if (!babylonLight.diffuse.equals(Color3.White())) {\r\n                        light.color = babylonLight.diffuse.asArray();\r\n                    }\r\n                    if (babylonLight.intensity !== 1.0) {\r\n                        light.intensity = babylonLight.intensity;\r\n                    }\r\n                    if (babylonLight.range !== Number.MAX_VALUE) {\r\n                        light.range = babylonLight.range;\r\n                    }\r\n\r\n                    if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                        const babylonSpotLight = babylonLight as SpotLight;\r\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\r\n                        }\r\n                        if (babylonSpotLight.innerAngle !== 0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\r\n                        }\r\n                    }\r\n\r\n                    if (this._lights == null) {\r\n                        this._lights = {\r\n                            lights: [],\r\n                        };\r\n                    }\r\n\r\n                    this._lights.lights.push(light);\r\n\r\n                    const lightReference: IKHRLightsPunctual_LightReference = {\r\n                        light: this._lights.lights.length - 1,\r\n                    };\r\n\r\n                    // Avoid duplicating the Light's parent node if possible.\r\n                    const parentBabylonNode = babylonNode.parent;\r\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\r\n                        const parentNode = this._exporter._nodes[nodeMap![parentBabylonNode.uniqueId]];\r\n                        if (parentNode) {\r\n                            const parentNodeLocalMatrix = TmpVectors.Matrix[0];\r\n                            const parentInvertNodeLocalMatrix = TmpVectors.Matrix[1];\r\n                            const parentNodeLocalTranslation = parentNode.translation\r\n                                ? new Vector3(parentNode.translation[0], parentNode.translation[1], parentNode.translation[2])\r\n                                : Vector3.Zero();\r\n                            const parentNodeLocalRotation = parentNode.rotation\r\n                                ? new Quaternion(parentNode.rotation[0], parentNode.rotation[1], parentNode.rotation[2], parentNode.rotation[3])\r\n                                : Quaternion.Identity();\r\n                            const parentNodeLocalScale = parentNode.scale ? new Vector3(parentNode.scale[0], parentNode.scale[1], parentNode.scale[2]) : Vector3.One();\r\n\r\n                            Matrix.ComposeToRef(parentNodeLocalScale, parentNodeLocalRotation, parentNodeLocalTranslation, parentNodeLocalMatrix);\r\n                            parentNodeLocalMatrix.invertToRef(parentInvertNodeLocalMatrix);\r\n\r\n                            // Convert light local matrix to local matrix relative to grandparent, facing -Z\r\n                            const lightLocalMatrix = TmpVectors.Matrix[2];\r\n                            const nodeLocalTranslation = node.translation ? new Vector3(node.translation[0], node.translation[1], node.translation[2]) : Vector3.Zero();\r\n\r\n                            // Undo directional light positional offset\r\n                            if (babylonLight instanceof DirectionalLight) {\r\n                                nodeLocalTranslation.subtractInPlace(\r\n                                    this._exporter._babylonScene.useRightHandedSystem\r\n                                        ? babylonLight.direction\r\n                                        : _GLTFUtilities._GetRightHandedPositionVector3(babylonLight.direction)\r\n                                );\r\n                            }\r\n                            const nodeLocalRotation = this._exporter._babylonScene.useRightHandedSystem ? Quaternion.Identity() : new Quaternion(0, 1, 0, 0);\r\n                            if (node.rotation) {\r\n                                nodeLocalRotation.multiplyInPlace(new Quaternion(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]));\r\n                            }\r\n                            const nodeLocalScale = node.scale ? new Vector3(node.scale[0], node.scale[1], node.scale[2]) : Vector3.One();\r\n\r\n                            Matrix.ComposeToRef(nodeLocalScale, nodeLocalRotation, nodeLocalTranslation, lightLocalMatrix);\r\n                            lightLocalMatrix.multiplyToRef(parentInvertNodeLocalMatrix, lightLocalMatrix);\r\n                            const parentNewScale = TmpVectors.Vector3[0];\r\n                            const parentNewRotationQuaternion = TmpVectors.Quaternion[0];\r\n                            const parentNewTranslation = TmpVectors.Vector3[1];\r\n\r\n                            lightLocalMatrix.decompose(parentNewScale, parentNewRotationQuaternion, parentNewTranslation);\r\n                            parentNode.scale = parentNewScale.asArray();\r\n                            parentNode.rotation = parentNewRotationQuaternion.asArray();\r\n                            parentNode.translation = parentNewTranslation.asArray();\r\n\r\n                            if (parentNode.extensions == null) {\r\n                                parentNode.extensions = {};\r\n                            }\r\n                            parentNode.extensions[NAME] = lightReference;\r\n\r\n                            // Do not export the original node\r\n                            resolve(null);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    if (node.extensions == null) {\r\n                        node.extensions = {};\r\n                    }\r\n\r\n                    node.extensions[NAME] = lightReference;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n"]}