{"version":3,"file":"glTFExporter.js","sourceRoot":"","sources":["../../../../../lts/serializers/generated/glTF/2.0/glTFExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, ImageMimeType, MeshPrimitiveMode, AccessorComponentType, CameraType } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { FloatArray, Nullable, IndicesArray } from \"core/types\";\r\nimport { Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, Vector4, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\n\r\n// Matrix that converts handedness on the X-axis.\r\nconst convertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n     */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n     */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Component Type (BYTE, UNSIGNED_BYTE, FLOAT, SHORT, INT, etc..)\r\n     */\r\n    accessorComponentType: AccessorComponentType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n     */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @internal\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores the glTF to export\r\n     */\r\n    public _glTF: IGLTF;\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    public _nodes: INode[];\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated glTF cameras\r\n     */\r\n    private _cameras: ICamera[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated glTF skins\r\n     */\r\n    public _skins: ISkin[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    public _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } };\r\n\r\n    protected _orderedImageData: Array<{ data: ArrayBuffer; mimeType: ImageMimeType }>;\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    public _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the source Babylon scene was left handed, and needed conversion.\r\n     */\r\n    public _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Specifies if a Babylon node should be converted to right-handed on export\r\n     */\r\n    public _convertToRightHandedSystemMap: { [nodeId: number]: boolean };\r\n\r\n    /*\r\n     * Specifies if root Babylon empty nodes that act as a coordinate space transform should be included in export\r\n     */\r\n    public _includeCoordinateSystemConversionNodes: boolean = false;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private _options: IExportOptions;\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtension<T>(\r\n        node: Nullable<T>,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._applyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        return currentPromise.then((newNode) => this._applyExtension(newNode, extensions, index + 1, actionAsync));\r\n    }\r\n\r\n    private _applyExtensions<T>(\r\n        node: Nullable<T>,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._applyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Nullable<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension, node) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, node, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(\r\n        context: string,\r\n        meshPrimitive: IMeshPrimitive,\r\n        babylonSubMesh: SubMesh,\r\n        binaryWriter: _BinaryWriter\r\n    ): Promise<Nullable<IMeshPrimitive>> {\r\n        return this._applyExtensions(\r\n            meshPrimitive,\r\n            (extension, node) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, node, babylonSubMesh, binaryWriter)\r\n        );\r\n    }\r\n\r\n    public _extensionsPostExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap?: { [key: number]: number },\r\n        binaryWriter?: _BinaryWriter\r\n    ): Promise<Nullable<INode>> {\r\n        return this._applyExtensions(node, (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, binaryWriter));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAsync(context: string, material: Nullable<IMaterial>, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        return this._applyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const output: BaseTexture[] = [];\r\n\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                if (this._glTF.extensionsUsed == null) {\r\n                    this._glTF.extensionsUsed = [];\r\n                }\r\n\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    if (this._glTF.extensionsRequired == null) {\r\n                        this._glTF.extensionsRequired = [];\r\n                    }\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                if (this._glTF.extensions == null) {\r\n                    this._glTF.extensions = {};\r\n                }\r\n\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene?: Nullable<Scene>, options?: IExportOptions) {\r\n        this._glTF = {\r\n            asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n        };\r\n        babylonScene = babylonScene || EngineStore.LastCreatedScene;\r\n        if (!babylonScene) {\r\n            return;\r\n        }\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._cameras = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._skins = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._orderedImageData = [];\r\n        this._options = options || {};\r\n        this._animationSampleRate = options && options.animationSampleRate ? options.animationSampleRate : 1 / 60;\r\n        this._includeCoordinateSystemConversionNodes = options && options.includeCoordinateSystemConversionNodes ? true : false;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const extensionKey in this._extensions) {\r\n            const extension = this._extensions[extensionKey];\r\n\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) {\r\n                    byteOffset = 0;\r\n                }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _reorderVertexAttributeDataBasedOnPrimitiveMode(\r\n        submesh: SubMesh,\r\n        primitiveMode: number,\r\n        sideOrientation: number,\r\n        vertexBufferKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        byteOffset: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ): void {\r\n        if (convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this._reorderTriangleFillMode(\r\n                        submesh,\r\n                        primitiveMode,\r\n                        sideOrientation,\r\n                        vertexBufferKind,\r\n                        meshAttributeArray,\r\n                        byteOffset,\r\n                        binaryWriter,\r\n                        convertToRightHandedSystem\r\n                    );\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this._reorderTriangleStripDrawMode(\r\n                        submesh,\r\n                        primitiveMode,\r\n                        sideOrientation,\r\n                        vertexBufferKind,\r\n                        meshAttributeArray,\r\n                        byteOffset,\r\n                        binaryWriter,\r\n                        convertToRightHandedSystem\r\n                    );\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this._reorderTriangleFanMode(\r\n                        submesh,\r\n                        primitiveMode,\r\n                        sideOrientation,\r\n                        vertexBufferKind,\r\n                        meshAttributeArray,\r\n                        byteOffset,\r\n                        binaryWriter,\r\n                        convertToRightHandedSystem\r\n                    );\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _reorderTriangleFillMode(\r\n        submesh: SubMesh,\r\n        primitiveMode: number,\r\n        sideOrientation: number,\r\n        vertexBufferKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        byteOffset: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error(\"The submesh vertices for the triangle fill mode is not divisible by 3!\");\r\n            } else {\r\n                const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            } else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this._writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n            }\r\n        } else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _reorderTriangleStripDrawMode(\r\n        submesh: SubMesh,\r\n        primitiveMode: number,\r\n        sideOrientation: number,\r\n        vertexBufferKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        byteOffset: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4\r\n                            ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index))\r\n                            : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this._writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        } else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _reorderTriangleFanMode(\r\n        submesh: SubMesh,\r\n        primitiveMode: number,\r\n        sideOrientation: number,\r\n        vertexBufferKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        byteOffset: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4\r\n                            ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index))\r\n                            : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this._writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        } else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _writeVertexAttributeData(\r\n        vertices: Vector2[] | Vector3[] | Vector4[],\r\n        byteOffset: number,\r\n        vertexAttributeKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        for (const vertex of vertices) {\r\n            if (convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    } else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    } else {\r\n                        Tools.Error(\"Unsupported vertex attribute kind!\");\r\n                    }\r\n                } else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            } else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (const component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param attributeComponentKind\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param stride Specifies the space between data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     * @param babylonTransformNode\r\n     */\r\n    public _writeAttributeData(\r\n        vertexBufferKind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        meshAttributeArray: FloatArray,\r\n        stride: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean,\r\n        babylonTransformNode: TransformNode\r\n    ) {\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                const meshMaterial = (babylonTransformNode as Mesh).material;\r\n                const convertToLinear = meshMaterial ? meshMaterial.getClassName() === \"StandardMaterial\" : true;\r\n                const vertexData: Color3 | Color4 = stride === 3 ? new Color3() : new Color4();\r\n                const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    if (stride === 3) {\r\n                        Color3.FromArrayToRef(meshAttributeArray, index, vertexData as Color3);\r\n                        if (convertToLinear) {\r\n                            (vertexData as Color3).toLinearSpaceToRef(vertexData as Color3, useExactSrgbConversions);\r\n                        }\r\n                    } else {\r\n                        Color4.FromArrayToRef(meshAttributeArray, index, vertexData as Color4);\r\n                        if (convertToLinear) {\r\n                            (vertexData as Color4).toLinearSpaceToRef(vertexData as Color4, useExactSrgbConversions);\r\n                        }\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(\r\n                        convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n\r\n        let writeBinaryFunc;\r\n        switch (attributeComponentKind) {\r\n            case AccessorComponentType.UNSIGNED_BYTE: {\r\n                writeBinaryFunc = binaryWriter.setUInt8.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_SHORT: {\r\n                writeBinaryFunc = binaryWriter.setUInt16.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_INT: {\r\n                writeBinaryFunc = binaryWriter.setUInt32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.FLOAT: {\r\n                writeBinaryFunc = binaryWriter.setFloat32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Attribute Component kind: \" + attributeComponentKind);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (const vertexAttribute of vertexAttributes) {\r\n            for (const component of vertexAttribute) {\r\n                writeBinaryFunc(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param attributeComponentKind\r\n     * @param meshPrimitive\r\n     * @param morphTarget\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param morphTargetAttributeArray\r\n     * @param stride Specifies the space between data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     * @param minMax\r\n     */\r\n    public writeMorphTargetAttributeData(\r\n        vertexBufferKind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        meshPrimitive: SubMesh,\r\n        morphTarget: MorphTarget,\r\n        meshAttributeArray: FloatArray,\r\n        morphTargetAttributeArray: FloatArray,\r\n        stride: number,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean,\r\n        minMax?: any\r\n    ) {\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n        let difference: Vector3 = new Vector3();\r\n        let difference4: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    const morphData = Vector3.FromArray(morphTargetAttributeArray, index);\r\n                    difference = morphData.subtractToRef(vertexData, difference);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(difference);\r\n                    }\r\n                    if (minMax) {\r\n                        minMax.min.copyFromFloats(Math.min(difference.x, minMax.min.x), Math.min(difference.y, minMax.min.y), Math.min(difference.z, minMax.min.z));\r\n                        minMax.max.copyFromFloats(Math.max(difference.x, minMax.max.x), Math.max(difference.y, minMax.max.y), Math.max(difference.z, minMax.max.z));\r\n                    }\r\n                    vertexAttributes.push(difference.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    vertexData.normalize();\r\n                    const morphData = Vector3.FromArray(morphTargetAttributeArray, index);\r\n                    morphData.normalize();\r\n                    difference = morphData.subtractToRef(vertexData, difference);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(difference);\r\n                    }\r\n                    vertexAttributes.push(difference.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * (stride + 1);\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n                    const morphData = Vector4.FromArray(morphTargetAttributeArray, index);\r\n                    _GLTFUtilities._NormalizeTangentFromRef(morphData);\r\n                    difference4 = morphData.subtractToRef(vertexData, difference4);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(difference4);\r\n                    }\r\n                    vertexAttributes.push([difference4.x, difference4.y, difference4.z]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n\r\n        let writeBinaryFunc;\r\n        switch (attributeComponentKind) {\r\n            case AccessorComponentType.UNSIGNED_BYTE: {\r\n                writeBinaryFunc = binaryWriter.setUInt8.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_SHORT: {\r\n                writeBinaryFunc = binaryWriter.setUInt16.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_INT: {\r\n                writeBinaryFunc = binaryWriter.setUInt32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.FLOAT: {\r\n                writeBinaryFunc = binaryWriter.setFloat32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Attribute Component kind: \" + attributeComponentKind);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (const vertexAttribute of vertexAttributes) {\r\n            for (const component of vertexAttribute) {\r\n                writeBinaryFunc(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private _generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: ArrayBuffer; mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                this._glTF.images = this._images;\r\n            } else {\r\n                this._glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        this._orderedImageData.push(imageData);\r\n                        imageName = image.uri.split(\".\")[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.byteLength, undefined, imageName);\r\n                        byteOffset += imageData.data.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!this._glTF.images) {\r\n                            this._glTF.images = [];\r\n                        }\r\n                        this._glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param dispose Dispose the exporter\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this._generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n            const glTFFileName = glTFPrefix + \".gltf\";\r\n            const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (const image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        const binaryWriter = new _BinaryWriter(4);\r\n        return this._createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this._generateJSON(true);\r\n            const glbFileName = glTFPrefix + \".glb\";\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            let jsonLength = jsonText.length;\r\n            let encodedJsonText;\r\n            let imageByteLength = 0;\r\n            // make use of TextEncoder when available\r\n            if (typeof TextEncoder !== \"undefined\") {\r\n                const encoder = new TextEncoder();\r\n                encodedJsonText = encoder.encode(jsonText);\r\n                jsonLength = encodedJsonText.length;\r\n            }\r\n            for (let i = 0; i < this._orderedImageData.length; ++i) {\r\n                imageByteLength += this._orderedImageData[i].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546c67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4e4f534a, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            // if TextEncoder was available, we can simply copy the encoded array\r\n            if (encodedJsonText) {\r\n                jsonData.set(encodedJsonText);\r\n            } else {\r\n                const blankCharCode = \"_\".charCodeAt(0);\r\n                for (let i = 0; i < jsonLength; ++i) {\r\n                    const charCode = jsonText.charCodeAt(i);\r\n                    // if the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                    if (charCode != jsonText.codePointAt(i)) {\r\n                        jsonData[i] = blankCharCode;\r\n                    } else {\r\n                        jsonData[i] = charCode;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004e4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let i = 0; i < this._orderedImageData.length; ++i) {\r\n                glbData.push(this._orderedImageData[i].data);\r\n            }\r\n\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: \"application/octet-stream\" });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = convertToRightHandedSystem\r\n                ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray()\r\n                : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!Quaternion.IsIdentity(rotationQuaternion)) {\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: Camera, convertToRightHandedSystem: boolean): void {\r\n        if (!babylonCamera.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonCamera.position).asArray() : babylonCamera.position.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = (<any>babylonCamera).rotationQuaternion; // we target the local transformation if one.\r\n\r\n        if (rotationQuaternion && !Quaternion.IsIdentity(rotationQuaternion)) {\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind, true)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind, true);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param attributeComponentKind Indicates the numerical type used to store the data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     * @param byteStride\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _createBufferViewKind(\r\n        kind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        babylonTransformNode: TransformNode,\r\n        binaryWriter: _BinaryWriter,\r\n        byteStride: number,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        const bufferMesh =\r\n            babylonTransformNode instanceof Mesh\r\n                ? (babylonTransformNode as Mesh)\r\n                : babylonTransformNode instanceof InstancedMesh\r\n                ? (babylonTransformNode as InstancedMesh).sourceMesh\r\n                : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(kind, true);\r\n            const vertexData = bufferMesh.getVerticesData(kind, undefined, undefined, true);\r\n\r\n            if (vertexBuffer && vertexData) {\r\n                const typeByteLength = VertexBuffer.GetTypeByteLength(attributeComponentKind);\r\n                const byteLength = vertexData.length * typeByteLength;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this._writeAttributeData(kind, attributeComponentKind, vertexData, byteStride / typeByteLength, binaryWriter, convertToRightHandedSystem, babylonTransformNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param babylonSubMesh The Babylon submesh that the morph target is applied to\r\n     * @param meshPrimitive\r\n     * @param babylonMorphTarget the morph target to be exported\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _setMorphTargetAttributes(\r\n        babylonSubMesh: SubMesh,\r\n        meshPrimitive: IMeshPrimitive,\r\n        babylonMorphTarget: MorphTarget,\r\n        binaryWriter: _BinaryWriter,\r\n        convertToRightHandedSystem: boolean\r\n    ) {\r\n        if (babylonMorphTarget) {\r\n            if (!meshPrimitive.targets) {\r\n                meshPrimitive.targets = [];\r\n            }\r\n            const target: { [attribute: string]: number } = {};\r\n            const mesh = babylonSubMesh.getMesh() as Mesh;\r\n            if (babylonMorphTarget.hasNormals) {\r\n                const vertexNormals = mesh.getVerticesData(VertexBuffer.NormalKind, undefined, undefined, true)!;\r\n                const morphNormals = babylonMorphTarget.getNormals()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_NORMAL\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"NORMAL\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.NORMAL = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(\r\n                    VertexBuffer.NormalKind,\r\n                    AccessorComponentType.FLOAT,\r\n                    babylonSubMesh,\r\n                    babylonMorphTarget,\r\n                    vertexNormals,\r\n                    morphNormals,\r\n                    byteStride / 4,\r\n                    binaryWriter,\r\n                    convertToRightHandedSystem\r\n                );\r\n            }\r\n            if (babylonMorphTarget.hasPositions) {\r\n                const vertexPositions = mesh.getVerticesData(VertexBuffer.PositionKind, undefined, undefined, true)!;\r\n                const morphPositions = babylonMorphTarget.getPositions()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_POSITION\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const minMax = { min: new Vector3(Infinity, Infinity, Infinity), max: new Vector3(-Infinity, -Infinity, -Infinity) };\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"POSITION\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.POSITION = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(\r\n                    VertexBuffer.PositionKind,\r\n                    AccessorComponentType.FLOAT,\r\n                    babylonSubMesh,\r\n                    babylonMorphTarget,\r\n                    vertexPositions,\r\n                    morphPositions,\r\n                    byteStride / 4,\r\n                    binaryWriter,\r\n                    convertToRightHandedSystem,\r\n                    minMax\r\n                );\r\n                accessor.min = minMax.min!.asArray();\r\n                accessor.max = minMax.max!.asArray();\r\n            }\r\n            if (babylonMorphTarget.hasTangents) {\r\n                const vertexTangents = mesh.getVerticesData(VertexBuffer.TangentKind, undefined, undefined, true)!;\r\n                const morphTangents = babylonMorphTarget.getTangents()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_NORMAL\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"TANGENT\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.TANGENT = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(\r\n                    VertexBuffer.TangentKind,\r\n                    AccessorComponentType.FLOAT,\r\n                    babylonSubMesh,\r\n                    babylonMorphTarget,\r\n                    vertexTangents,\r\n                    morphTangents,\r\n                    byteStride / 4,\r\n                    binaryWriter,\r\n                    convertToRightHandedSystem\r\n                );\r\n            }\r\n            meshPrimitive.targets.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private _getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        if (babylonMesh instanceof InstancedMesh || babylonMesh instanceof Mesh) {\r\n            const baseMesh = babylonMesh instanceof Mesh ? babylonMesh : babylonMesh.sourceMesh;\r\n            if (typeof baseMesh.overrideRenderingFillMode === \"number\") {\r\n                return baseMesh.overrideRenderingFillMode;\r\n            }\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private _setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private _setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesKind: {\r\n                meshPrimitive.attributes.JOINTS_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesExtraKind: {\r\n                meshPrimitive.attributes.JOINTS_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsKind: {\r\n                meshPrimitive.attributes.WEIGHTS_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsExtraKind: {\r\n                meshPrimitive.attributes.WEIGHTS_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private _setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): Promise<void> {\r\n        const promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let minMax: { min: Nullable<number[]>; max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = babylonTransformNode as Mesh;\r\n        } else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesIndicesKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.UNSIGNED_SHORT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesIndicesExtraKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.UNSIGNED_SHORT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesWeightsKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.MatricesWeightsExtraKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this._getMeshPrimitiveMode(bufferMesh);\r\n            const vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n            const morphTargetManager = bufferMesh.morphTargetManager;\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                const attributeComponentKind = attribute.accessorComponentType;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind, true)) {\r\n                    const vertexBuffer = this._getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer\r\n                        ? vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(attribute.accessorComponentType)\r\n                        : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this._createBufferViewKind(attributeKind, attributeComponentKind, babylonTransformNode, binaryWriter, attribute.byteStride, convertToRightHandedSystem);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + \" material\",\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha]),\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        } else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        } else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    const glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this._setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if ((attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) && !this._options.exportUnusedUVs) {\r\n                            if (!glTFMaterial || !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        const vertexData = bufferMesh.getVerticesData(attributeKind, undefined, undefined, true);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this._getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) {\r\n                                    // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(\r\n                                        bufferViewIndex,\r\n                                        attributeKind + \" - \" + babylonTransformNode.name,\r\n                                        attribute.accessorType,\r\n                                        attribute.accessorComponentType,\r\n                                        vertexData.length / stride,\r\n                                        0,\r\n                                        minMax.min,\r\n                                        minMax.max\r\n                                    );\r\n                                    this._accessors.push(accessor);\r\n                                    this._setAttributeKind(meshPrimitive, attributeKind);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(\r\n                            indexBufferViewIndex,\r\n                            \"indices - \" + babylonTransformNode.name,\r\n                            AccessorType.SCALAR,\r\n                            AccessorComponentType.UNSIGNED_INT,\r\n                            submesh.indexCount,\r\n                            submesh.indexStart * 4,\r\n                            null,\r\n                            null\r\n                        );\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        const sideOrientation = bufferMesh.overrideMaterialSideOrientation !== null ? bufferMesh.overrideMaterialSideOrientation : babylonMaterial.sideOrientation;\r\n\r\n                        if (\r\n                            (sideOrientation == Material.ClockWiseSideOrientation && this._babylonScene.useRightHandedSystem) ||\r\n                            (sideOrientation == Material.ClockWiseSideOrientation &&\r\n                                convertToRightHandedSystem &&\r\n                                bufferMesh.overrideMaterialSideOrientation !== bufferMesh.material?.sideOrientation)\r\n                        ) {\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) {\r\n                                byteOffset = 0;\r\n                            }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this._reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            } else {\r\n                                for (const attribute of attributeData) {\r\n                                    const vertexData = bufferMesh.getVerticesData(attribute.kind, undefined, undefined, true);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this._reorderVertexAttributeDataBasedOnPrimitiveMode(\r\n                                            submesh,\r\n                                            primitiveMode,\r\n                                            sideOrientation,\r\n                                            attribute.kind,\r\n                                            vertexData,\r\n                                            byteOffset,\r\n                                            binaryWriter,\r\n                                            convertToRightHandedSystem\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n                    }\r\n                    if (morphTargetManager) {\r\n                        let target;\r\n                        for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                            target = morphTargetManager.getTarget(i);\r\n                            this._setMorphTargetAttributes(submesh, meshPrimitive, target, binaryWriter, convertToRightHandedSystem);\r\n                        }\r\n                    }\r\n\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    promises.push();\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the node is used to convert its descendants from a right handed coordinate system to the Babylon scene's coordinate system.\r\n     * @param node The node to check\r\n     * @returns True if the node is used to convert its descendants from right-handed to left-handed. False otherwise\r\n     */\r\n    private _isBabylonCoordinateSystemConvertingNode(node: Node): boolean {\r\n        if (node instanceof TransformNode) {\r\n            // Transform\r\n            const matrix = node.getWorldMatrix().multiplyToRef(convertHandednessMatrix, TmpVectors.Matrix[0]);\r\n            if (!matrix.isIdentity()) {\r\n                return false;\r\n            }\r\n\r\n            // Geometry\r\n            if ((node instanceof Mesh && node.geometry !== null) || (node instanceof InstancedMesh && node.sourceMesh.geometry !== null)) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private _createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes: Node[] = [...babylonScene.transformNodes, ...babylonScene.meshes, ...babylonScene.lights, ...babylonScene.cameras];\r\n        const rootNodesToLeftHanded: Node[] = [];\r\n\r\n        this._convertToRightHandedSystem = !babylonScene.useRightHandedSystem;\r\n        this._convertToRightHandedSystemMap = {};\r\n\r\n        // Scene metadata\r\n        if (babylonScene.metadata) {\r\n            if (this._options.metadataSelector) {\r\n                scene.extras = this._options.metadataSelector(babylonScene.metadata);\r\n            } else if (babylonScene.metadata.gltf) {\r\n                scene.extras = babylonScene.metadata.gltf.extras;\r\n            }\r\n        }\r\n\r\n        // Set default values for all nodes\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            this._convertToRightHandedSystemMap[rootNode.uniqueId] = this._convertToRightHandedSystem;\r\n            rootNode.getDescendants(false).forEach((descendant) => {\r\n                this._convertToRightHandedSystemMap[descendant.uniqueId] = this._convertToRightHandedSystem;\r\n            });\r\n        });\r\n\r\n        // Check if root nodes converting to left-handed are present\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            if (this._includeCoordinateSystemConversionNodes) {\r\n                return;\r\n            }\r\n\r\n            if (this._isBabylonCoordinateSystemConvertingNode(rootNode)) {\r\n                rootNodesToLeftHanded.push(rootNode);\r\n\r\n                // Exclude the node from list of nodes to export\r\n                const indexRootNode = nodes.indexOf(rootNode);\r\n                if (indexRootNode !== -1) {\r\n                    // should always be true\r\n                    nodes.splice(indexRootNode, 1);\r\n                }\r\n\r\n                // Cancel conversion to right handed system\r\n                rootNode.getDescendants(false).forEach((descendant) => {\r\n                    this._convertToRightHandedSystemMap[descendant.uniqueId] = false;\r\n                });\r\n            }\r\n        });\r\n\r\n        // Export babylon cameras to glTFCamera\r\n        const cameraMap = new Map<Camera, number>();\r\n        babylonScene.cameras.forEach((camera) => {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(camera)) {\r\n                const glTFCamera: ICamera = {\r\n                    type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n                };\r\n\r\n                if (camera.name) {\r\n                    glTFCamera.name = camera.name;\r\n                }\r\n\r\n                if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                    glTFCamera.perspective = {\r\n                        aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                        yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                        znear: camera.minZ,\r\n                        zfar: camera.maxZ,\r\n                    };\r\n                } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                    const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                    const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                    glTFCamera.orthographic = {\r\n                        xmag: halfWidth,\r\n                        ymag: halfHeight,\r\n                        znear: camera.minZ,\r\n                        zfar: camera.maxZ,\r\n                    };\r\n                }\r\n\r\n                cameraMap.set(camera, this._cameras.length);\r\n                this._cameras.push(glTFCamera);\r\n            }\r\n        });\r\n\r\n        const [exportNodes, exportMaterials] = this._getExportNodes(nodes);\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(exportMaterials, ImageMimeType.PNG, true).then(() => {\r\n            return this._createNodeMapAndAnimationsAsync(babylonScene, exportNodes, binaryWriter).then((nodeMap) => {\r\n                return this._createSkinsAsync(babylonScene, nodeMap, binaryWriter).then((skinMap) => {\r\n                    this._nodeMap = nodeMap;\r\n\r\n                    this._totalByteLength = binaryWriter.getByteOffset();\r\n                    if (this._totalByteLength == undefined) {\r\n                        throw new Error(\"undefined byte length!\");\r\n                    }\r\n\r\n                    // Build Hierarchy with the node map.\r\n                    for (const babylonNode of nodes) {\r\n                        glTFNodeIndex = this._nodeMap[babylonNode.uniqueId];\r\n                        if (glTFNodeIndex !== undefined) {\r\n                            glTFNode = this._nodes[glTFNodeIndex];\r\n\r\n                            if (babylonNode.metadata) {\r\n                                if (this._options.metadataSelector) {\r\n                                    glTFNode.extras = this._options.metadataSelector(babylonNode.metadata);\r\n                                } else if (babylonNode.metadata.gltf) {\r\n                                    glTFNode.extras = babylonNode.metadata.gltf.extras;\r\n                                }\r\n                            }\r\n\r\n                            if (babylonNode instanceof Camera) {\r\n                                glTFNode.camera = cameraMap.get(babylonNode);\r\n                            }\r\n\r\n                            if (!babylonNode.parent || rootNodesToLeftHanded.indexOf(babylonNode.parent) !== -1) {\r\n                                if (this._options.shouldExportNode && !this._options.shouldExportNode(babylonNode)) {\r\n                                    Tools.Log(\"Omitting \" + babylonNode.name + \" from scene.\");\r\n                                } else {\r\n                                    const convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                                    if (convertToRightHandedSystem) {\r\n                                        if (glTFNode.translation) {\r\n                                            glTFNode.translation[2] *= -1;\r\n                                            glTFNode.translation[0] *= -1;\r\n                                        }\r\n                                        glTFNode.rotation = glTFNode.rotation\r\n                                            ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray()\r\n                                            : Quaternion.FromArray([0, 1, 0, 0]).asArray();\r\n                                    }\r\n\r\n                                    scene.nodes.push(glTFNodeIndex);\r\n                                }\r\n                            }\r\n\r\n                            if (babylonNode instanceof Mesh) {\r\n                                const babylonMesh: Mesh = babylonNode;\r\n                                if (babylonMesh.skeleton) {\r\n                                    glTFNode.skin = skinMap[babylonMesh.skeleton.uniqueId];\r\n                                }\r\n                            }\r\n\r\n                            directDescendents = babylonNode.getDescendants(true);\r\n                            if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                                const children: number[] = [];\r\n                                for (const descendent of directDescendents) {\r\n                                    if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                        children.push(this._nodeMap[descendent.uniqueId]);\r\n                                    }\r\n                                }\r\n                                if (children.length) {\r\n                                    glTFNode.children = children;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (scene.nodes.length) {\r\n                        this._scenes.push(scene);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Getting the nodes and materials that would be exported.\r\n     * @param nodes Babylon transform nodes\r\n     * @returns Array of nodes which would be exported.\r\n     * @returns Set of materials which would be exported.\r\n     */\r\n    private _getExportNodes(nodes: Node[]): [Node[], Set<Material>] {\r\n        const exportNodes: Node[] = [];\r\n        const exportMaterials: Set<Material> = new Set<Material>();\r\n\r\n        for (const babylonNode of nodes) {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(babylonNode)) {\r\n                exportNodes.push(babylonNode);\r\n\r\n                const babylonMesh = babylonNode as AbstractMesh;\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    const material = babylonMesh.material || babylonMesh.getScene().defaultMaterial;\r\n                    if (material instanceof MultiMaterial) {\r\n                        for (const subMaterial of material.subMaterials) {\r\n                            if (subMaterial) {\r\n                                exportMaterials.add(subMaterial);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        exportMaterials.add(material);\r\n                    }\r\n                }\r\n            } else {\r\n                `Excluding node ${babylonNode.name}`;\r\n            }\r\n        }\r\n\r\n        return [exportNodes, exportMaterials];\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private _createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: Node[], binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        const runtimeGLTFAnimation: IAnimation = {\r\n            name: \"runtime animations\",\r\n            channels: [],\r\n            samplers: [],\r\n        };\r\n        const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (const babylonNode of nodes) {\r\n            promiseChain = promiseChain.then(() => {\r\n                const convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                return this._createNodeAsync(babylonNode, binaryWriter, convertToRightHandedSystem).then((node) => {\r\n                    const promise = this._extensionsPostExportNodeAsync(\"createNodeAsync\", node, babylonNode, nodeMap, binaryWriter);\r\n                    if (promise == null) {\r\n                        Tools.Warn(`Not exporting node ${babylonNode.name}`);\r\n                        return Promise.resolve();\r\n                    } else {\r\n                        return promise.then((node) => {\r\n                            if (!node) {\r\n                                return;\r\n                            }\r\n                            this._nodes.push(node);\r\n                            nodeIndex = this._nodes.length - 1;\r\n                            nodeMap[babylonNode.uniqueId] = nodeIndex;\r\n\r\n                            if (!babylonScene.animationGroups.length) {\r\n                                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                                    babylonNode,\r\n                                    runtimeGLTFAnimation,\r\n                                    idleGLTFAnimations,\r\n                                    nodeMap,\r\n                                    this._nodes,\r\n                                    binaryWriter,\r\n                                    this._bufferViews,\r\n                                    this._accessors,\r\n                                    convertToRightHandedSystem,\r\n                                    this._animationSampleRate,\r\n                                    this._options.shouldExportAnimation\r\n                                );\r\n                                if (babylonNode.animations.length) {\r\n                                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                                        babylonNode,\r\n                                        runtimeGLTFAnimation,\r\n                                        idleGLTFAnimations,\r\n                                        nodeMap,\r\n                                        this._nodes,\r\n                                        binaryWriter,\r\n                                        this._bufferViews,\r\n                                        this._accessors,\r\n                                        convertToRightHandedSystem,\r\n                                        this._animationSampleRate,\r\n                                        this._options.shouldExportAnimation\r\n                                    );\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                    babylonScene,\r\n                    this._animations,\r\n                    nodeMap,\r\n                    this._nodes,\r\n                    binaryWriter,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._convertToRightHandedSystemMap,\r\n                    this._animationSampleRate,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonNode Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     * @returns glTF node\r\n     */\r\n    private _createNodeAsync(babylonNode: Node, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonNode.name) {\r\n                node.name = babylonNode.name;\r\n            }\r\n\r\n            if (babylonNode instanceof TransformNode) {\r\n                // Set transformation\r\n                this._setNodeTransformation(node, babylonNode, convertToRightHandedSystem);\r\n                if (babylonNode instanceof Mesh) {\r\n                    const morphTargetManager = babylonNode.morphTargetManager;\r\n                    if (morphTargetManager && morphTargetManager.numTargets > 0) {\r\n                        mesh.weights = [];\r\n                        for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                            mesh.weights.push(morphTargetManager.getTarget(i).influence);\r\n                        }\r\n                    }\r\n                }\r\n                return this._setPrimitiveAttributesAsync(mesh, babylonNode, binaryWriter, convertToRightHandedSystem).then(() => {\r\n                    if (mesh.primitives.length) {\r\n                        this._meshes.push(mesh);\r\n                        node.mesh = this._meshes.length - 1;\r\n                    }\r\n                    return node;\r\n                });\r\n            } else if (babylonNode instanceof Camera) {\r\n                this._setCameraTransformation(node, babylonNode, convertToRightHandedSystem);\r\n                return node;\r\n            } else {\r\n                return node;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF skin from a Babylon skeleton\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodeMap Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private _createSkinsAsync(babylonScene: Scene, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        const promiseChain = Promise.resolve();\r\n        const skinMap: { [key: number]: number } = {};\r\n        for (const skeleton of babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n            // create skin\r\n            const skin: ISkin = { joints: [] };\r\n            const inverseBindMatrices: Matrix[] = [];\r\n\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex];\r\n                inverseBindMatrices.push(bone.getInvertedAbsoluteTransform());\r\n\r\n                const transformNode = bone.getTransformNode();\r\n                if (transformNode && nodeMap[transformNode.uniqueId] !== null && nodeMap[transformNode.uniqueId] !== undefined) {\r\n                    skin.joints.push(nodeMap[transformNode.uniqueId]);\r\n                } else {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported\");\r\n                }\r\n            }\r\n\r\n            if (skin.joints.length > 0) {\r\n                // create buffer view for inverse bind matrices\r\n                const byteStride = 64; // 4 x 4 matrix of 32 bit float\r\n                const byteLength = inverseBindMatrices.length * byteStride;\r\n                const bufferViewOffset = binaryWriter.getByteOffset();\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, bufferViewOffset, byteLength, undefined, \"InverseBindMatrices\" + \" - \" + skeleton.name);\r\n                this._bufferViews.push(bufferView);\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const bindMatrixAccessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    \"InverseBindMatrices\" + \" - \" + skeleton.name,\r\n                    AccessorType.MAT4,\r\n                    AccessorComponentType.FLOAT,\r\n                    inverseBindMatrices.length,\r\n                    null,\r\n                    null,\r\n                    null\r\n                );\r\n                const inverseBindAccessorIndex = this._accessors.push(bindMatrixAccessor) - 1;\r\n                skin.inverseBindMatrices = inverseBindAccessorIndex;\r\n                this._skins.push(skin);\r\n                skinMap[skeleton.uniqueId] = this._skins.length - 1;\r\n\r\n                inverseBindMatrices.forEach((mat) => {\r\n                    mat.m.forEach((cell: number) => {\r\n                        binaryWriter.setFloat32(cell);\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        return promiseChain.then(() => {\r\n            return skinMap;\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private _resizeBuffer(byteLength: number): ArrayBuffer {\r\n        const newBuffer = new ArrayBuffer(byteLength);\r\n        const copyOldBufferSize = Math.min(this._arrayBuffer.byteLength, byteLength);\r\n        const oldUint8Array = new Uint8Array(this._arrayBuffer, 0, copyOldBufferSize);\r\n        const newUint8Array = new Uint8Array(newBuffer);\r\n        newUint8Array.set(oldUint8Array, 0);\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this._resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset, entry);\r\n            this._byteOffset += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores an UInt16 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt16(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint16(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 2 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint16(this._byteOffset, entry, true);\r\n            this._byteOffset += 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        } else {\r\n            Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            throw new Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error(\"Invalid data being written!\");\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary length!\");\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n    /**\r\n     * Stores an Int16 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setInt16(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setInt16(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 2 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setInt16(this._byteOffset, entry, true);\r\n            this._byteOffset += 2;\r\n        }\r\n    }\r\n    /**\r\n     * Stores a byte in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setByte(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setInt8(byteOffset, entry);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setInt8(this._byteOffset, entry);\r\n            this._byteOffset++;\r\n        }\r\n    }\r\n}\r\n"]}